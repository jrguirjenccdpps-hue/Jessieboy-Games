<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0a0a0f">
    <title>NEON ARCADE Mobile</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap');
        
        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff88;
            --neon-yellow: #ffff00;
            --dark-bg: #0a0a0f;
            --panel-bg: rgba(20, 20, 35, 0.9);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: var(--dark-bg);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        .bg-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 243, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 243, 255, 0.03) 1px, transparent 1px);
            background-size: 30px 30px;
            pointer-events: none;
            z-index: -1;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 10px;
        }

        header {
            text-align: center;
            padding: 20px 10px;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8em;
            font-weight: 900;
            background: linear-gradient(45deg, var(--neon-blue), var(--neon-pink), var(--neon-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 0.9em;
            color: rgba(255,255,255,0.7);
            margin-top: 5px;
        }

        .stats-bar {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
            font-size: 0.8em;
        }

        .stat-item {
            background: var(--panel-bg);
            padding: 8px 12px;
            border-radius: 15px;
            border: 1px solid var(--glass-border);
        }

        /* Mobile-optimized game cards */
        .games-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        .game-card {
            background: var(--panel-bg);
            border-radius: 15px;
            overflow: hidden;
            border: 1px solid var(--glass-border);
            touch-action: pan-y;
        }

        .game-header {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, rgba(0,0,0,0.3), transparent);
        }

        .game-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1em;
            font-weight: 700;
        }

        .game-badge {
            background: linear-gradient(135deg, var(--neon-pink), var(--neon-blue));
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.7em;
        }

        .game-container {
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            min-height: auto;
        }

        .score-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 6px 12px;
            border-radius: 15px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9em;
            color: var(--neon-yellow);
            border: 1px solid var(--neon-yellow);
            z-index: 10;
        }

        .high-score {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            color: var(--neon-green);
            border: 1px solid var(--neon-green);
            z-index: 10;
        }

        /* Mobile Controls */
        .mobile-controls {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, rgba(0, 243, 255, 0.2), rgba(255, 0, 255, 0.2));
            border: 2px solid var(--neon-blue);
            border-radius: 15px;
            color: #fff;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        .control-btn:active {
            background: var(--neon-blue);
            transform: scale(0.95);
        }

        .control-btn.large {
            grid-column: span 2;
            width: 130px;
        }

        /* Swipe zones */
        .swipe-zone {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 5;
            touch-action: none;
        }

        /* Game-specific mobile styles */
        .grid-2048 {
            display: grid;
            grid-template-columns: repeat(4, 65px);
            gap: 8px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 12px;
            border-radius: 12px;
            touch-action: none;
        }

        .tile-2048 {
            width: 65px;
            height: 65px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.4em;
            font-weight: 700;
            color: #fff;
            transition: all 0.15s;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .snake-grid {
            display: grid;
            grid-template-columns: repeat(15, 18px);
            gap: 1px;
            background: linear-gradient(135deg, #0d2818, #1a4d2e);
            padding: 8px;
            border-radius: 8px;
            touch-action: none;
        }

        .snake-cell {
            width: 18px;
            height: 18px;
            background: rgba(0,0,0,0.3);
            border-radius: 3px;
        }

        .tetris-board {
            display: grid;
            grid-template-columns: repeat(10, 25px);
            gap: 1px;
            background: #000;
            padding: 5px;
            border-radius: 5px;
            touch-action: none;
        }

        .tetris-cell {
            width: 25px;
            height: 25px;
            background: #111;
            border-radius: 2px;
        }

        .wordle-grid {
            display: grid;
            grid-template-columns: repeat(5, 50px);
            gap: 6px;
            margin-bottom: 10px;
        }

        .wordle-cell {
            width: 50px;
            height: 50px;
            border: 2px solid #3a3a3c;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            font-weight: 700;
            border-radius: 6px;
            color: #fff;
        }

        .mines-grid {
            display: grid;
            grid-template-columns: repeat(8, 35px);
            gap: 2px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 8px;
            border-radius: 8px;
            touch-action: none;
        }

        .mine-cell {
            width: 35px;
            height: 35px;
            background: linear-gradient(135deg, #4a4a6a, #3a3a5a);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.9em;
            touch-action: manipulation;
        }

        .flappy-container {
            width: 100%;
            max-width: 350px;
            height: 250px;
            background: linear-gradient(to bottom, #4fc3f7 0%, #81d4fa 50%, #8bc34a 50%, #689f38 100%);
            position: relative;
            overflow: hidden;
            border-radius: 12px;
            touch-action: none;
        }

        .flappy-bird {
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, #ffeb3b, #fbc02d);
            border-radius: 50%;
            position: absolute;
            left: 40px;
            border: 2px solid #f57f17;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 10;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 38px);
            gap: 0;
            border: 3px solid #8b4513;
            border-radius: 5px;
            overflow: hidden;
            touch-action: manipulation;
        }

        .chess-cell {
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            touch-action: manipulation;
        }

        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 32px);
            gap: 0;
            background: #1a1a2e;
            padding: 3px;
            border-radius: 8px;
            touch-action: manipulation;
        }

        .sudoku-cell {
            width: 32px;
            height: 32px;
            border: 1px solid #2a2a4a;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1em;
            font-weight: 700;
            background: rgba(255,255,255,0.05);
            color: #fff;
            touch-action: manipulation;
        }

        .platformer-canvas {
            width: 100%;
            max-width: 350px;
            height: 200px;
            background: linear-gradient(to bottom, #87ceeb 0%, #e0f6ff 40%, #8b4513 40%, #654321 100%);
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            touch-action: none;
        }

        .td-canvas {
            width: 100%;
            max-width: 350px;
            height: 220px;
            background: linear-gradient(135deg, #1b5e20, #2e7d32);
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            touch-action: manipulation;
        }

        /* Virtual keyboard for Wordle/Sudoku */
        .virtual-keyboard {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-top: 10px;
            width: 100%;
            max-width: 350px;
        }

        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 4px;
        }

        .vkey {
            min-width: 28px;
            height: 42px;
            background: linear-gradient(135deg, #4a4a6a, #3a3a5a);
            border: none;
            border-radius: 5px;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
        }

        .vkey.wide {
            min-width: 50px;
        }

        .vkey:active {
            background: var(--neon-blue);
            transform: scale(0.95);
        }

        /* Action buttons */
        .controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            background: linear-gradient(135deg, rgba(0, 243, 255, 0.2), rgba(255, 0, 255, 0.2));
            color: #fff;
            border: 1px solid var(--neon-blue);
            padding: 10px 18px;
            border-radius: 20px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 0.8em;
            text-transform: uppercase;
            touch-action: manipulation;
        }

        button:active {
            background: var(--neon-blue);
            color: #000;
        }

        button.danger {
            border-color: #ff1744;
            background: rgba(255, 23, 68, 0.2);
        }

        .instructions {
            margin-top: 10px;
            font-size: 0.8em;
            color: rgba(255,255,255,0.6);
            text-align: center;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 15, 0.98);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 100;
            border: 2px solid var(--neon-pink);
            min-width: 200px;
        }

        .game-over h3 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3em;
            margin-bottom: 10px;
        }

        /* Difficulty selector */
        .difficulty-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            justify-content: center;
        }

        .diff-btn {
            padding: 6px 12px;
            font-size: 0.7em;
            border-radius: 12px;
        }

        .diff-btn.active {
            background: var(--neon-blue);
            color: #000;
        }

        /* D-pad for platformer */
        .dpad {
            display: grid;
            grid-template-columns: repeat(3, 55px);
            grid-template-rows: repeat(2, 55px);
            gap: 5px;
            margin-top: 10px;
        }

        .dpad-btn {
            width: 55px;
            height: 55px;
            background: linear-gradient(135deg, rgba(0, 243, 255, 0.2), rgba(255, 0, 255, 0.2));
            border: 2px solid var(--neon-blue);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3em;
            touch-action: none;
            user-select: none;
        }

        .dpad-btn:active {
            background: var(--neon-blue);
        }

        .dpad-btn.up { grid-column: 2; }
        .dpad-btn.left { grid-column: 1; grid-row: 2; }
        .dpad-btn.right { grid-column: 3; grid-row: 2; }
        .dpad-btn.down { grid-column: 2; grid-row: 2; }

        /* Notification */
        .notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--panel-bg);
            border: 1px solid var(--neon-green);
            padding: 12px 24px;
            border-radius: 25px;
            color: var(--neon-green);
            font-weight: 700;
            z-index: 1000;
            transition: transform 0.3s;
        }

        .notification.show {
            transform: translateX(-50%) translateY(0);
        }

        /* Touch feedback */
        .touch-feedback {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 243, 255, 0.3);
            pointer-events: none;
            animation: touchRipple 0.5s ease-out;
            z-index: 1000;
        }

        @keyframes touchRipple {
            to { transform: scale(2); opacity: 0; }
        }

        /* Prevent text selection */
        .no-select {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Landscape warning */
        .rotate-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--dark-bg);
            z-index: 9999;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            text-align: center;
            padding: 20px;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .rotate-warning {
                display: flex;
            }
        }

        /* iPhone notch support */
        @supports (padding-top: env(safe-area-inset-top)) {
            .container {
                padding-top: env(safe-area-inset-top);
                padding-bottom: env(safe-area-inset-bottom);
            }
        }
    </style>
</head>
<body class="no-select">
    <div class="bg-grid"></div>
    <div class="rotate-warning">
        <div style="font-size: 3em; margin-bottom: 20px;">üì±</div>
        <h2>Please Rotate Your Device</h2>
        <p>This game is optimized for portrait mode</p>
    </div>

    <div class="notification" id="notification">Game Saved!</div>

    <div class="container">
        <header>
            <h1>NEON ARCADE</h1>
            <p class="subtitle">Mobile Edition ‚Ä¢ Touch to Play</p>
            
            <div class="stats-bar">
                <div class="stat-item">
                    <span>üèÜ <span id="totalScore">0</span></span>
                </div>
                <div class="stat-item">
                    <span>üéÆ <span id="gamesPlayed">0</span></span>
                </div>
                <button onclick="saveAllGames()" style="padding: 6px 12px; font-size: 0.7em;">üíæ</button>
                <button onclick="loadAllGames()" style="padding: 6px 12px; font-size: 0.7em;">üìÇ</button>
            </div>
        </header>

        <div class="games-grid">
            <!-- Game 1: 2048 (Swipe) -->
            <div class="game-card">
                <div class="game-header">
                    <span class="game-title">2048 SWIPE</span>
                    <span class="game-badge">SWIPE</span>
                </div>
                <div class="game-container" id="game2048">
                    <div class="high-score">Best: <span id="best2048">0</span></div>
                    <div class="score-display">Score: <span id="score2048">0</span></div>
                    <div class="grid-2048" id="grid2048"></div>
                    <div class="swipe-zone" id="swipe2048"></div>
                    <div class="game-over lose" id="over2048">
                        <h3>Game Over</h3>
                        <div style="margin: 10px 0;">Score: <span id="final2048">0</span></div>
                        <button onclick="init2048()">Try Again</button>
                    </div>
                </div>
                <div class="controls">
                    <button onclick="init2048()">üîÑ New</button>
                    <button onclick="undo2048()">‚Ü©Ô∏è Undo</button>
                </div>
                <p class="instructions">üëÜ Swipe up/down/left/right to move tiles</p>
            </div>

            <!-- Game 2: Snake (D-Pad) -->
            <div class="game-card">
                <div class="game-header">
                    <span class="game-title">Cyber Snake</span>
                    <span class="game-badge">ARCADE</span>
                </div>
                <div class="game-container" id="gameSnake">
                    <div class="high-score">Best: <span id="bestSnake">0</span></div>
                    <div class="score-display">Score: <span id="scoreSnake">0</span></div>
                    <div class="snake-grid" id="snakeGrid"></div>
                    <div class="game-over lose" id="overSnake">
                        <h3>Game Over</h3>
                        <div style="margin: 10px 0;">Score: <span id="finalSnake">0</span></div>
                        <button onclick="initSnake()">Try Again</button>
                    </div>
                </div>
                <div class="dpad" id="snakeControls">
                    <div class="dpad-btn up" ontouchstart="snakeSetDir(0, -1)">‚ñ≤</div>
                    <div class="dpad-btn left" ontouchstart="snakeSetDir(-1, 0)">‚óÄ</div>
                    <div class="dpad-btn down" ontouchstart="snakeSetDir(0, 1)">‚ñº</div>
                    <div class="dpad-btn right" ontouchstart="snakeSetDir(1, 0)">‚ñ∂</div>
                </div>
                <div class="controls" style="margin-top: 10px;">
                    <button onclick="toggleSnake()" id="btnSnake">‚ñ∂Ô∏è Start</button>
                </div>
            </div>

            <!-- Game 3: Tetris (Touch Controls) -->
            <div class="game-card">
                <div class="game-header">
                    <span class="game-title">Block Matrix</span>
                    <span class="game-badge">PUZZLE</span>
                </div>
                <div class="game-container" id="gameTetris">
                    <div class="high-score">Best: <span id="bestTetris">0</span></div>
                    <div class="score-display">Score: <span id="scoreTetris">0</span></div>
                    <div class="tetris-board" id="tetrisBoard"></div>
                    <div class="game-over lose" id="overTetris">
                        <h3>Game Over</h3>
                        <div style="margin: 10px 0;">Score: <span id="finalTetris">0</span></div>
                        <button onclick="initTetris()">Try Again</button>
                    </div>
                </div>
                <div class="mobile-controls" style="grid-template-columns: repeat(4, 65px);">
                    <div class="control-btn" ontouchstart="tetrisMove(-1)">‚óÄ</div>
                    <div class="control-btn" ontouchstart="tetrisRotate()">‚Üª</div>
                    <div class="control-btn" ontouchstart="tetrisMove(1)">‚ñ∂</div>
                    <div class="control-btn" ontouchstart="tetrisDrop()" style="background: rgba(255,0,0,0.3); border-color: #ff1744;">‚¨á</div>
                </div>
                <div class="controls">
                    <button onclick="toggleTetris()" id="btnTetris">‚ñ∂Ô∏è Start</button>
                </div>
            </div>

            <!-- Game 4: Wordle (Virtual Keyboard) -->
            <div class="game-card">
                <div class="game-header">
                    <span class="game-title">Word Cipher</span>
                    <span class="game-badge">WORD</span>
                </div>
                <div class="game-container" id="gameWordle">
                    <div class="high-score">Streak: <span id="streakWordle">0</span></div>
                    <div class="score-display">Guess: <span id="guessesWordle">0</span>/6</div>
                    <div class="wordle-grid" id="wordleGrid"></div>
                    <div class="virtual-keyboard" id="wordleKeyboard"></div>
                    <div class="game-over win" id="overWordle">
                        <h3 id="wordleMsg">Excellent!</h3>
                        <div style="margin: 10px 0;">Word: <span id="wordleAnswer"></span></div>
                        <button onclick="initWordle()">Next</button>
                    </div>
                </div>
            </div>

            <!-- Game 5: Minesweeper (Touch) -->
            <div class="game-card">
                <div class="game-header">
                    <span class="game-title">Mine Field</span>
                    <span class="game-badge">STRATEGY</span>
                </div>
                <div class="game-container" id="gameMines">
                    <div class="high-score">Wins: <span id="winsMines">0</span></div>
                    <div class="score-display">‚è±Ô∏è <span id="timerMines">0</span>s | üö© <span id="mineCount">10</span></div>
                    <div class="difficulty-selector">
                        <button class="diff-btn active" onclick="setMinesDifficulty(8, 10)">Easy</button>
                        <button class="diff-btn" onclick="setMinesDifficulty(12, 20)">Med</button>
                        <button class="diff-btn" onclick="setMinesDifficulty(16, 40)">Hard</button>
                    </div>
                    <div class="mines-grid" id="minesGrid"></div>
                    <div class="game-over" id="overMines">
                        <h3 id="minesTitle">Game Over</h3>
                        <div style="margin: 10px 0;" id="minesMsg">Time: 0s</div>
                        <button onclick="initMines()">Try Again</button>
                    </div>
                </div>
                <div class="controls">
                    <button onclick="initMines()">üîÑ New</button>
                    <button onclick="setFlagMode()" id="flagBtn">üö© Flag: OFF</button>
                </div>
                <p class="instructions">üëÜ Tap to reveal ‚Ä¢ Flag mode to mark mines</p>
            </div>

            <!-- Game 6: Flappy Bird (Tap) -->
            <div class="game-card">
                <div class="game-header">
                    <span class="game-title">Neon Flight</span>
                    <span class="game-badge">TAP</span>
                </div>
                <div class="game-container" id="gameFlappy">
                    <div class="high-score">Best: <span id="bestFlappy">0</span></div>
                    <div class="score-display">Score: <span id="scoreFlappy">0</span></div>
                    <div class="flappy-container" id="flappyContainer" ontouchstart="flappyJump(event)">
                        <div class="flappy-bird" id="flappyBird"></div>
                    </div>
                    <div class="game-over lose" id="overFlappy">
                        <h3>Crash!</h3>
                        <div style="margin: 10px 0;">Score: <span id="finalFlappy">0</span></div>
                        <button onclick="initFlappy()">Try Again</button>
                    </div>
                </div>
                <div class="controls">
                    <button onclick="toggleFlappy()" id="btnFlappy">‚ñ∂Ô∏è Start</button>
                </div>
                <p class="instructions">üëÜ Tap screen to jump ‚Ä¢ Avoid pipes</p>
            </div>

            <!-- Game 7: Chess (Touch) -->
            <div class="game-card">
                <div class="game-header">
                    <span class="game-title">Cyber Chess</span>
                    <span class="game-badge">STRATEGY</span>
                </div>
                <div class="game-container" id="gameChess">
                    <div class="high-score" id="chessTurn">White</div>
                    <div class="score-display" id="chessStatus">Select piece</div>
                    <div class="chess-board" id="chessBoard"></div>
                    <div class="game-over win" id="overChess">
                        <h3 id="chessResult">Checkmate!</h3>
                        <div style="margin: 10px 0;" id="chessWinner">White Wins!</div>
                        <button onclick="initChess()">New Game</button>
                    </div>
                </div>
                <div class="controls">
                    <button onclick="initChess()">üîÑ New</button>
                    <button onclick="undoChess()">‚Ü©Ô∏è Undo</button>
                    <button onclick="toggleAIChess()" id="btnAIChess">ü§ñ AI: OFF</button>
                </div>
            </div>

            <!-- Game 8: Sudoku (Virtual Numpad) -->
            <div class="game-card">
                <div class="game-header">
                    <span class="game-title">Number Matrix</span>
                    <span class="game-badge">LOGIC</span>
                </div>
                <div class="game-container" id="gameSudoku">
                    <div class="high-score">Solved: <span id="solvedSudoku">0</span></div>
                    <div class="score-display" id="sudokuStatus">Select cell</div>
                    <div class="difficulty-selector">
                        <button class="diff-btn active" onclick="setSudokuDifficulty(30)">Easy</button>
                        <button class="diff-btn" onclick="setSudokuDifficulty(40)">Med</button>
                        <button class="diff-btn" onclick="setSudokuDifficulty(50)">Hard</button>
                    </div>
                    <div class="sudoku-grid" id="sudokuGrid"></div>
                    <div class="virtual-keyboard" id="sudokuKeyboard"></div>
                    <div class="game-over win" id="overSudoku">
                        <h3>Solved!</h3>
                        <button onclick="initSudoku()">Next</button>
                    </div>
                </div>
            </div>

            <!-- Game 9: Platformer (Touch D-Pad) -->
            <div class="game-card">
                <div class="game-header">
                    <span class="game-title">Jump Core</span>
                    <span class="game-badge">ACTION</span>
                </div>
                <div class="game-container" id="gamePlatformer">
                    <div class="high-score">Level: <span id="levelPlatformer">1</span></div>
                    <div class="score-display">Coins: <span id="scorePlatformer">0</span></div>
                    <div class="platformer-canvas" id="platformerCanvas">
                        <div class="platformer-player" id="platformerPlayer"></div>
                        <div class="platformer-ground"></div>
                    </div>
                    <div class="game-over win" id="overPlatformer">
                        <h3>Complete!</h3>
                        <div style="margin: 10px 0;">Coins: <span id="finalPlatformer">0</span></div>
                        <button onclick="nextLevelPlatformer()">Next Level</button>
                    </div>
                </div>
                <div class="dpad" id="platControls">
                    <div class="dpad-btn up" ontouchstart="platJump()">‚ñ≤</div>
                    <div class="dpad-btn left" ontouchstart="platMove(-1)" ontouchend="platStop()">‚óÄ</div>
                    <div class="dpad-btn right" ontouchstart="platMove(1)" ontouchend="platStop()">‚ñ∂</div>
                </div>
                <div class="controls" style="margin-top: 10px;">
                    <button onclick="togglePlatformer()" id="btnPlatformer">‚ñ∂Ô∏è Start</button>
                </div>
            </div>

            <!-- Game 10: Tower Defense (Touch) -->
            <div class="game-card">
                <div class="game-header">
                    <span class="game-title">Defense Grid</span>
                    <span class="game-badge">TOWER</span>
                </div>
                <div class="game-container" id="gameTD">
                    <div class="high-score">Wave: <span id="waveTD">0</span></div>
                    <div class="score-display">‚ù§Ô∏è <span id="livesTD">20</span> | üí∞ <span id="goldTD">100</span></div>
                    <div class="td-canvas" id="tdCanvas" ontouchstart="placeTower(event)">
                        <div class="td-path"></div>
                    </div>
                    <div class="game-over lose" id="overTD">
                        <h3>Destroyed</h3>
                        <div style="margin: 10px 0;">Waves: <span id="finalWaveTD">0</span></div>
                        <button onclick="initTD()">Try Again</button>
                    </div>
                </div>
                <div class="controls">
                    <button onclick="toggleTD()" id="btnTD">‚ñ∂Ô∏è Wave</button>
                    <button onclick="upgradeTowers()">‚¨ÜÔ∏è Up (100g)</button>
                </div>
                <p class="instructions">üëÜ Tap to place towers ‚Ä¢ Stop the enemies!</p>
            </div>
        </div>
    </div>

    <script>
        // ==================== MOBILE UTILITIES ====================
        const STORAGE_KEY = 'neon_arcade_mobile_v1';
        let globalStats = { totalScore: 0, gamesPlayed: 0 };

        function showNotification(msg) {
            const notif = document.getElementById('notification');
            notif.textContent = msg;
            notif.classList.add('show');
            setTimeout(() => notif.classList.remove('show'), 2000);
        }

        function createTouchFeedback(x, y) {
            const feedback = document.createElement('div');
            feedback.className = 'touch-feedback';
            feedback.style.left = (x - 20) + 'px';
            feedback.style.top = (y - 20) + 'px';
            document.body.appendChild(feedback);
            setTimeout(() => feedback.remove(), 500);
        }

        // Prevent zoom on double tap
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);

        // ==================== SAVE/LOAD ====================
        function saveAllGames() {
            const data = { globalStats, timestamp: Date.now() };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            showNotification('üíæ Saved!');
        }

        function loadAllGames() {
            const data = JSON.parse(localStorage.getItem(STORAGE_KEY));
            if (data) {
                globalStats = data.globalStats;
                updateGlobalStats();
                showNotification('üìÇ Loaded!');
            }
        }

        function updateGlobalStats() {
            document.getElementById('totalScore').textContent = globalStats.totalScore.toLocaleString();
            document.getElementById('gamesPlayed').textContent = globalStats.gamesPlayed;
        }

        // ==================== GAME 1: 2048 (Swipe) ====================
        let grid2048 = [], score2048 = 0, best2048 = 0, undoStack2048 = [];

        function init2048() {
            grid2048 = Array(4).fill().map(() => Array(4).fill(0));
            score2048 = 0;
            undoStack2048 = [];
            document.getElementById('score2048').textContent = '0';
            document.getElementById('over2048').style.display = 'none';
            addTile2048();
            addTile2048();
            render2048();
            setupSwipe2048();
        }

        function setupSwipe2048() {
            const zone = document.getElementById('swipe2048');
            let startX, startY;
            
            zone.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                createTouchFeedback(startX, startY);
            }, {passive: true});
            
            zone.addEventListener('touchend', (e) => {
                if (!startX || !startY) return;
                const endX = e.changedTouches[0].clientX;
                const endY = e.changedTouches[0].clientY;
                
                const dx = endX - startX;
                const dy = endY - startY;
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (Math.abs(dx) > 30) move2048(dx > 0 ? 'right' : 'left');
                } else {
                    if (Math.abs(dy) > 30) move2048(dy > 0 ? 'down' : 'up');
                }
                
                startX = startY = null;
            }, {passive: true});
        }

        function addTile2048() {
            let empty = [];
            for (let r = 0; r < 4; r++)
                for (let c = 0; c < 4; c++)
                    if (!grid2048[r][c]) empty.push({r, c});
            if (empty.length) {
                let {r, c} = empty[Math.floor(Math.random() * empty.length)];
                grid2048[r][c] = Math.random() < 0.9 ? 2 : 4;
            }
        }

        function render2048() {
            const grid = document.getElementById('grid2048');
            grid.innerHTML = '';
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 4; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'tile-2048';
                    if (grid2048[r][c]) {
                        cell.textContent = grid2048[r][c];
                        cell.setAttribute('data-value', grid2048[r][c]);
                    }
                    grid.appendChild(cell);
                }
            }
        }

        function move2048(direction) {
            undoStack2048.push({grid: grid2048.map(r => [...r]), score: score2048});
            if (undoStack2048.length > 10) undoStack2048.shift();

            let moved = false;
            const rotate = (grid, times) => {
                for (let i = 0; i < times; i++)
                    grid = grid[0].map((_, c) => grid.map(r => r[c]).reverse());
                return grid;
            };

            let working = grid2048.map(r => [...r]);
            let rotations = {up: 3, right: 2, down: 1, left: 0};
            working = rotate(working, rotations[direction]);

            for (let r = 0; r < 4; r++) {
                let row = working[r].filter(x => x);
                for (let i = 0; i < row.length - 1; i++) {
                    if (row[i] === row[i + 1]) {
                        row[i] *= 2;
                        score2048 += row[i];
                        row.splice(i + 1, 1);
                        moved = true;
                    }
                }
                while (row.length < 4) row.push(0);
                if (row.join(',') !== working[r].join(',')) moved = true;
                working[r] = row;
            }

            working = rotate(working, (4 - rotations[direction]) % 4);
            if (moved) {
                grid2048 = working;
                addTile2048();
                render2048();
                document.getElementById('score2048').textContent = score2048;
                if (score2048 > best2048) {
                    best2048 = score2048;
                    document.getElementById('best2048').textContent = best2048;
                }
                if (!canMove2048()) {
                    document.getElementById('final2048').textContent = score2048;
                    document.getElementById('over2048').style.display = 'block';
                }
            }
        }

        function undo2048() {
            if (undoStack2048.length) {
                const prev = undoStack2048.pop();
                grid2048 = prev.grid;
                score2048 = prev.score;
                render2048();
                document.getElementById('score2048').textContent = score2048;
            }
        }

        function canMove2048() {
            for (let r = 0; r < 4; r++)
                for (let c = 0; c < 4; c++)
                    if (!grid2048[r][c]) return true;
            for (let r = 0; r < 4; r++)
                for (let c = 0; c < 4; c++)
                    if ((r < 3 && grid2048[r][c] === grid2048[r + 1][c]) ||
                        (c < 3 && grid2048[r][c] === grid2048[r][c + 1])) return true;
            return false;
        }

        // ==================== GAME 2: SNAKE (Touch) ====================
        let snake = [], food = {}, dir = {x: 1, y: 0}, nextDir = {x: 1, y: 0};
        let snakeInterval, scoreSnake = 0, bestSnake = 0, snakeRunning = false;

        function initSnake() {
            snake = [{x: 7, y: 7}];
            dir = {x: 1, y: 0};
            nextDir = {x: 1, y: 0};
            scoreSnake = 0;
            document.getElementById('scoreSnake').textContent = '0';
            document.getElementById('overSnake').style.display = 'none';
            placeFoodSnake();
            renderSnake();
        }

        function snakeSetDir(dx, dy) {
            if ((dx !== 0 && dir.x === 0) || (dy !== 0 && dir.y === 0)) {
                nextDir = {x: dx, y: dy};
            }
            if (!snakeRunning) toggleSnake();
        }

        function placeFoodSnake() {
            do {
                food = {x: Math.floor(Math.random() * 15), y: Math.floor(Math.random() * 15)};
            } while (snake.some(s => s.x === food.x && s.y === food.y));
        }

        function renderSnake() {
            const grid = document.getElementById('snakeGrid');
            grid.innerHTML = '';
            for (let y = 0; y < 15; y++) {
                for (let x = 0; x < 15; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'snake-cell';
                    if (snake[0].x === x && snake[0].y === y) cell.classList.add('snake-head');
                    else if (snake.some(s => s.x === x && s.y === y)) cell.classList.add('snake-body');
                    else if (food.x === x && food.y === y) cell.classList.add('snake-food');
                    grid.appendChild(cell);
                }
            }
        }

        function updateSnake() {
            dir = nextDir;
            const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};
            
            if (head.x < 0 || head.x >= 15 || head.y < 0 || head.y >= 15 || 
                snake.some(s => s.x === head.x && s.y === head.y)) {
                gameOverSnake();
                return;
            }

            snake.unshift(head);
            if (head.x === food.x && head.y === food.y) {
                scoreSnake += 10;
                document.getElementById('scoreSnake').textContent = scoreSnake;
                placeFoodSnake();
            } else {
                snake.pop();
            }
            renderSnake();
        }

        function gameOverSnake() {
            clearInterval(snakeInterval);
            snakeRunning = false;
            document.getElementById('btnSnake').textContent = '‚ñ∂Ô∏è Start';
            document.getElementById('finalSnake').textContent = scoreSnake;
            document.getElementById('overSnake').style.display = 'block';
            if (scoreSnake > bestSnake) {
                bestSnake = scoreSnake;
                document.getElementById('bestSnake').textContent = bestSnake;
            }
        }

        function toggleSnake() {
            if (snakeRunning) {
                clearInterval(snakeInterval);
                snakeRunning = false;
                document.getElementById('btnSnake').textContent = '‚ñ∂Ô∏è Resume';
            } else {
                if (snake.length === 0) initSnake();
                snakeInterval = setInterval(updateSnake, 120);
                snakeRunning = true;
                document.getElementById('btnSnake').textContent = '‚è∏Ô∏è Pause';
            }
        }

        // ==================== GAME 3: TETRIS (Touch) ====================
        const tetrominoes = {
            I: {shape: [[1,1,1,1]], color: 'I'},
            O: {shape: [[1,1],[1,1]], color: 'O'},
            T: {shape: [[0,1,0],[1,1,1]], color: 'T'},
            S: {shape: [[0,1,1],[1,1,0]], color: 'S'},
            Z: {shape: [[1,1,0],[0,1,1]], color: 'Z'},
            J: {shape: [[1,0,0],[1,1,1]], color: 'J'},
            L: {shape: [[0,0,1],[1,1,1]], color: 'L'}
        };

        let boardTetris = [], currentPiece = null, scoreTetris = 0, bestTetris = 0;
        let tetrisInterval, tetrisRunning = false;

        function initTetris() {
            boardTetris = Array(20).fill().map(() => Array(10).fill(0));
            scoreTetris = 0;
            document.getElementById('scoreTetris').textContent = '0';
            document.getElementById('overTetris').style.display = 'none';
            spawnPiece();
            renderTetris();
        }

        function spawnPiece() {
            const types = Object.keys(tetrominoes);
            const type = types[Math.floor(Math.random() * types.length)];
            currentPiece = {
                type: type,
                shape: tetrominoes[type].shape.map(r => [...r]),
                x: 3,
                y: 0,
                color: tetrominoes[type].color
            };
            if (!isValidTetris(currentPiece.shape, currentPiece.x, currentPiece.y)) {
                gameOverTetris();
            }
        }

        function isValidTetris(shape, x, y) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const newX = x + c, newY = y + r;
                        if (newX < 0 || newX >= 10 || newY >= 20) return false;
                        if (newY >= 0 && boardTetris[newY][newX]) return false;
                    }
                }
            }
            return true;
        }

        function renderTetris() {
            const display = boardTetris.map(r => [...r]);
            if (currentPiece) {
                for (let r = 0; r < currentPiece.shape.length; r++) {
                    for (let c = 0; c < currentPiece.shape[r].length; c++) {
                        if (currentPiece.shape[r][c]) {
                            const y = currentPiece.y + r;
                            const x = currentPiece.x + c;
                            if (y >= 0) display[y][x] = currentPiece.color;
                        }
                    }
                }
            }

            const grid = document.getElementById('tetrisBoard');
            grid.innerHTML = '';
            for (let r = 0; r < 20; r++) {
                for (let c = 0; c < 10; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'tetris-cell';
                    if (display[r][c]) cell.classList.add('tetris-' + display[r][c]);
                    grid.appendChild(cell);
                }
            }
        }

        function updateTetris() {
            if (!currentPiece) return;
            if (isValidTetris(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) {
                currentPiece.y++;
            } else {
                lockPiece();
                clearLines();
                spawnPiece();
            }
            renderTetris();
        }

        function lockPiece() {
            for (let r = 0; r < currentPiece.shape.length; r++) {
                for (let c = 0; c < currentPiece.shape[r].length; c++) {
                    if (currentPiece.shape[r][c]) {
                        const y = currentPiece.y + r;
                        const x = currentPiece.x + c;
                        if (y >= 0) boardTetris[y][x] = currentPiece.color;
                    }
                }
            }
        }

        function clearLines() {
            let lines = 0;
            for (let r = 19; r >= 0; r--) {
                if (boardTetris[r].every(c => c !== 0)) {
                    boardTetris.splice(r, 1);
                    boardTetris.unshift(Array(10).fill(0));
                    lines++;
                    r++;
                }
            }
            if (lines) {
                scoreTetris += lines * 100;
                document.getElementById('scoreTetris').textContent = scoreTetris;
            }
        }

        function tetrisMove(dx) {
            if (!currentPiece) return;
            if (isValidTetris(currentPiece.shape, currentPiece.x + dx, currentPiece.y)) {
                currentPiece.x += dx;
                renderTetris();
            }
        }

        function tetrisRotate() {
            if (!currentPiece) return;
            const rotated = currentPiece.shape[0].map((_, i) => 
                currentPiece.shape.map(row => row[i]).reverse()
            );
            if (isValidTetris(rotated, currentPiece.x, currentPiece.y)) {
                currentPiece.shape = rotated;
                renderTetris();
            }
        }

        function tetrisDrop() {
            if (!currentPiece) return;
            while (isValidTetris(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) {
                currentPiece.y++;
                scoreTetris += 2;
            }
            document.getElementById('scoreTetris').textContent = scoreTetris;
            updateTetris();
        }

        function gameOverTetris() {
            clearInterval(tetrisInterval);
            tetrisRunning = false;
            document.getElementById('btnTetris').textContent = '‚ñ∂Ô∏è Start';
            document.getElementById('finalTetris').textContent = scoreTetris;
            document.getElementById('overTetris').style.display = 'block';
            if (scoreTetris > bestTetris) {
                bestTetris = scoreTetris;
                document.getElementById('bestTetris').textContent = bestTetris;
            }
        }

        function toggleTetris() {
            if (tetrisRunning) {
                clearInterval(tetrisInterval);
                tetrisRunning = false;
                document.getElementById('btnTetris').textContent = '‚ñ∂Ô∏è Resume';
            } else {
                if (!currentPiece) initTetris();
                tetrisInterval = setInterval(updateTetris, 500);
                tetrisRunning = true;
                document.getElementById('btnTetris').textContent = '‚è∏Ô∏è Pause';
            }
        }

        // ==================== GAME 4: WORDLE (Virtual Keyboard) ====================
        const wordList = ['REACT', 'HOUSE', 'PLANE', 'WATER', 'MUSIC', 'LIGHT', 'POWER', 'BRAIN', 'MOUSE', 'PHONE', 'WORLD', 'BEACH', 'DANCE', 'LAUGH', 'DREAM', 'SMILE', 'HEART', 'SPACE', 'ROBOT', 'CYBER'];
        let targetWord = '', currentRow = 0, currentCol = 0, gridWordle = [], streakWordle = 0;

        function initWordle() {
            targetWord = wordList[Math.floor(Math.random() * wordList.length)];
            currentRow = 0;
            currentCol = 0;
            gridWordle = Array(6).fill().map(() => Array(5).fill(''));
            document.getElementById('overWordle').style.display = 'none';
            document.getElementById('guessesWordle').textContent = '0';
            renderWordle();
            createWordleKeyboard();
        }

        function renderWordle() {
            const grid = document.getElementById('wordleGrid');
            grid.innerHTML = '';
            for (let r = 0; r < 6; r++) {
                for (let c = 0; c < 5; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'wordle-cell';
                    cell.textContent = gridWordle[r][c];
                    if (r < currentRow) {
                        const target = targetWord.split('');
                        if (target[c] === gridWordle[r][c]) cell.classList.add('wordle-correct');
                        else if (target.includes(gridWordle[r][c])) cell.classList.add('wordle-present');
                        else cell.classList.add('wordle-absent');
                    }
                    grid.appendChild(cell);
                }
            }
        }

        function createWordleKeyboard() {
            const kb = document.getElementById('wordleKeyboard');
            kb.innerHTML = '';
            const rows = ['QWERTYUIOP', 'ASDFGHJKL', 'ZXCVBNM'];
            rows.forEach((row, i) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'keyboard-row';
                row.split('').forEach(char => {
                    const key = document.createElement('button');
                    key.className = 'vkey';
                    key.textContent = char;
                    key.ontouchstart = () => inputLetter(char);
                    key.id = 'key-' + char;
                    rowDiv.appendChild(key);
                });
                if (i === 2) {
                    const enter = document.createElement('button');
                    enter.className = 'vkey wide';
                    enter.textContent = '‚èé';
                    enter.ontouchstart = submitGuess;
                    rowDiv.appendChild(enter);
                    
                    const del = document.createElement('button');
                    del.className = 'vkey wide';
                    del.textContent = '‚å´';
                    del.ontouchstart = deleteLetter;
                    rowDiv.appendChild(del);
                }
                kb.appendChild(rowDiv);
            });
        }

        function inputLetter(char) {
            if (currentCol < 5 && currentRow < 6) {
                gridWordle[currentRow][currentCol] = char;
                currentCol++;
                renderWordle();
            }
        }

        function deleteLetter() {
            if (currentCol > 0) {
                currentCol--;
                gridWordle[currentRow][currentCol] = '';
                renderWordle();
            }
        }

        function submitGuess() {
            if (currentCol !== 5) return;
            const guess = gridWordle[currentRow].join('');
            
            for (let c = 0; c < 5; c++) {
                const char = gridWordle[currentRow][c];
                const key = document.getElementById('key-' + char);
                const target = targetWord.split('');
                if (target[c] === char) key.style.background = '#538d4e';
                else if (target.includes(char)) key.style.background = '#b59f3b';
                else key.style.background = '#3a3a3c';
            }

            document.getElementById('guessesWordle').textContent = currentRow + 1;
            renderWordle();

            if (guess === targetWord) {
                streakWordle++;
                document.getElementById('streakWordle').textContent = streakWordle;
                document.getElementById('wordleMsg').textContent = ['Genius!', 'Magnificent!', 'Impressive!', 'Splendid!', 'Great!', 'Phew!'][currentRow];
                document.getElementById('wordleAnswer').textContent = targetWord;
                document.getElementById('overWordle').style.display = 'block';
            } else if (currentRow === 5) {
                streakWordle = 0;
                document.getElementById('streakWordle').textContent = streakWordle;
                document.getElementById('wordleMsg').textContent = targetWord;
                document.getElementById('overWordle').style.display = 'block';
            }
            
            currentRow++;
            currentCol = 0;
        }

        // ==================== GAME 5: MINESWEEPER (Touch) ====================
        let minesGrid = [], minesRevealed = [], minesFlagged = [], minePositions = [];
        let minesWidth = 8, minesHeight = 8, minesCount = 10;
        let timerMines, timerMinesValue = 0, winsMines = 0;
        let firstClick = true, flagMode = false;

        function setMinesDifficulty(w, c) {
            minesWidth = w;
            minesHeight = w;
            minesCount = c;
            document.querySelectorAll('#gameMines .diff-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            initMines();
        }

        function initMines() {
            clearInterval(timerMines);
            timerMinesValue = 0;
            document.getElementById('timerMines').textContent = '0';
            firstClick = true;
            flagMode = false;
            document.getElementById('flagBtn').textContent = 'üö© Flag: OFF';
            
            minesGrid = Array(minesHeight).fill().map(() => Array(minesWidth).fill(0));
            minesRevealed = Array(minesHeight).fill().map(() => Array(minesWidth).fill(false));
            minesFlagged = Array(minesHeight).fill().map(() => Array(minesWidth).fill(false));
            minePositions = [];
            
            const gridEl = document.getElementById('minesGrid');
            gridEl.style.gridTemplateColumns = `repeat(${minesWidth}, 35px)`;
            
            document.getElementById('mineCount').textContent = minesCount;
            document.getElementById('overMines').style.display = 'none';
            renderMines();
        }

        function setFlagMode() {
            flagMode = !flagMode;
            document.getElementById('flagBtn').textContent = flagMode ? 'üö© Flag: ON' : 'üö© Flag: OFF';
        }

        function placeMines(excludeR, excludeC) {
            let placed = 0;
            while (placed < minesCount) {
                const r = Math.floor(Math.random() * minesHeight);
                const c = Math.floor(Math.random() * minesWidth);
                if (!minesGrid[r][c] && !(r === excludeR && c === excludeC)) {
                    minesGrid[r][c] = -1;
                    minePositions.push({r, c});
                    placed++;
                }
            }

            for (let r = 0; r < minesHeight; r++) {
                for (let c = 0; c < minesWidth; c++) {
                    if (minesGrid[r][c] !== -1) {
                        let count = 0;
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < minesHeight && nc >= 0 && nc < minesWidth && minesGrid[nr][nc] === -1) count++;
                            }
                        }
                        minesGrid[r][c] = count;
                    }
                }
            }
        }

        function renderMines() {
            const grid = document.getElementById('minesGrid');
            grid.innerHTML = '';
            for (let r = 0; r < minesHeight; r++) {
                for (let c = 0; c < minesWidth; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'mine-cell';
                    if (minesRevealed[r][c]) {
                        cell.classList.add('revealed');
                        if (minesGrid[r][c] === -1) {
                            cell.classList.add('mine');
                            cell.textContent = 'üí£';
                        } else if (minesGrid[r][c] > 0) {
                            cell.textContent = minesGrid[r][c];
                        }
                    } else if (minesFlagged[r][c]) {
                        cell.classList.add('flagged');
                        cell.textContent = 'üö©';
                    }
                    cell.ontouchstart = (e) => handleMineTouch(r, c, e);
                    grid.appendChild(cell);
                }
            }
        }

        function handleMineTouch(r, c, e) {
            e.preventDefault();
            createTouchFeedback(e.touches[0].clientX, e.touches[0].clientY);
            
            if (flagMode) {
                if (!minesRevealed[r][c]) {
                    minesFlagged[r][c] = !minesFlagged[r][c];
                    const flagged = minesFlagged.flat().filter(f => f).length;
                    document.getElementById('mineCount').textContent = minesCount - flagged;
                    renderMines();
                }
            } else {
                revealCell(r, c);
            }
        }

        function revealCell(r, c) {
            if (minesRevealed[r][c] || minesFlagged[r][c]) return;
            
            if (firstClick) {
                placeMines(r, c);
                firstClick = false;
                timerMines = setInterval(() => {
                    timerMinesValue++;
                    document.getElementById('timerMines').textContent = timerMinesValue;
                }, 1000);
            }
            
            minesRevealed[r][c] = true;
            
            if (minesGrid[r][c] === -1) {
                gameOverMines(false);
            } else if (minesGrid[r][c] === 0) {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const nr = r + dr, nc = c + dc;
                        if (nr >= 0 && nr < minesHeight && nc >= 0 && nc < minesWidth) revealCell(nr, nc);
                    }
                }
            }
            
            checkWinMines();
            renderMines();
        }

        function checkWinMines() {
            let revealed = 0;
            for (let r = 0; r < minesHeight; r++)
                for (let c = 0; c < minesWidth; c++)
                    if (minesRevealed[r][c]) revealed++;
            if (revealed === minesWidth * minesHeight - minesCount) {
                gameOverMines(true);
            }
        }

        function gameOverMines(won) {
            clearInterval(timerMines);
            minePositions.forEach(m => minesRevealed[m.r][m.c] = true);
            renderMines();
            
            const over = document.getElementById('overMines');
            document.getElementById('minesTitle').textContent = won ? 'Victory!' : 'BOOM!';
            document.getElementById('minesMsg').textContent = `Time: ${timerMinesValue}s`;
            over.style.display = 'block';
            
            if (won) {
                winsMines++;
                document.getElementById('winsMines').textContent = winsMines;
            }
        }

        // ==================== GAME 6: FLAPPY BIRD (Tap) ====================
        let flappyY = 100, flappyVel = 0, flappyScore = 0, bestFlappy = 0;
        let flappyInterval, flappyRunning = false;
        let pipes = [], pipeTimer = 0;

        function initFlappy() {
            flappyY = 100;
            flappyVel = 0;
            flappyScore = 0;
            pipes = [];
            pipeTimer = 0;
            document.getElementById('scoreFlappy').textContent = '0';
            document.getElementById('overFlappy').style.display = 'none';
            document.getElementById('flappyBird').style.top = flappyY + 'px';
            document.querySelectorAll('.flappy-pipe').forEach(p => p.remove());
        }

        function flappyJump(e) {
            if (e) {
                e.preventDefault();
                createTouchFeedback(e.touches[0].clientX, e.touches[0].clientY);
            }
            if (!flappyRunning) {
                toggleFlappy();
                return;
            }
            flappyVel = -10;
        }

        function updateFlappy() {
            flappyVel += 0.5;
            flappyY += flappyVel;

            const bird = document.getElementById('flappyBird');
            bird.style.top = flappyY + 'px';
            bird.style.transform = `rotate(${Math.min(flappyVel * 3, 90)}deg)`;

            pipeTimer++;
            if (pipeTimer > 100) {
                createPipe();
                pipeTimer = 0;
            }

            pipes.forEach((pipe, i) => {
                pipe.x -= 3;
                pipe.topEl.style.right = (320 - pipe.x) + 'px';
                pipe.bottomEl.style.right = (320 - pipe.x) + 'px';

                if (!pipe.passed && pipe.x < 55) {
                    flappyScore++;
                    document.getElementById('scoreFlappy').textContent = flappyScore;
                    pipe.passed = true;
                }

                if (pipe.x < -60) {
                    pipe.topEl.remove();
                    pipe.bottomEl.remove();
                    pipes.splice(i, 1);
                }

                if (50 < pipe.x + 50 && 85 > pipe.x) {
                    if (flappyY < pipe.gapY || flappyY + 30 > pipe.gapY + 90) {
                        gameOverFlappy();
                    }
                }
            });

            if (flappyY > 220 || flappyY < -30) gameOverFlappy();
        }

        function createPipe() {
            const gapY = Math.random() * 80 + 50;
            const topHeight = gapY;
            const bottomHeight = 250 - gapY - 90;

            const topPipe = document.createElement('div');
            topPipe.className = 'flappy-pipe';
            topPipe.style.cssText = `height: ${topHeight}px; top: 0; width: 50px; background: linear-gradient(to right, #4caf50, #2e7d32); position: absolute; right: -50px;`;
            
            const bottomPipe = document.createElement('div');
            bottomPipe.className = 'flappy-pipe';
            bottomPipe.style.cssText = `height: ${bottomHeight}px; bottom: 0; width: 50px; background: linear-gradient(to right, #4caf50, #2e7d32); position: absolute; right: -50px;`;

            document.getElementById('flappyContainer').appendChild(topPipe);
            document.getElementById('flappyContainer').appendChild(bottomPipe);

            pipes.push({
                x: 320,
                gapY: gapY,
                topEl: topPipe,
                bottomEl: bottomPipe,
                passed: false
            });
        }

        function gameOverFlappy() {
            clearInterval(flappyInterval);
            flappyRunning = false;
            document.getElementById('btnFlappy').textContent = '‚ñ∂Ô∏è Start';
            document.getElementById('finalFlappy').textContent = flappyScore;
            document.getElementById('overFlappy').style.display = 'block';
            if (flappyScore > bestFlappy) {
                bestFlappy = flappyScore;
                document.getElementById('bestFlappy').textContent = bestFlappy;
            }
        }

        function toggleFlappy() {
            if (flappyRunning) {
                clearInterval(flappyInterval);
                flappyRunning = false;
                document.getElementById('btnFlappy').textContent = '‚ñ∂Ô∏è Resume';
            } else {
                flappyInterval = setInterval(updateFlappy, 1000/60);
                flappyRunning = true;
                document.getElementById('btnFlappy').textContent = '‚è∏Ô∏è Pause';
            }
        }

        // ==================== GAME 7: CHESS (Touch) ====================
        const chessPieces = {
            'r': '‚ôú', 'n': '‚ôû', 'b': '‚ôù', 'q': '‚ôõ', 'k': '‚ôö', 'p': '‚ôü',
            'R': '‚ôñ', 'N': '‚ôò', 'B': '‚ôó', 'Q': '‚ôï', 'K': '‚ôî', 'P': '‚ôô'
        };

        let chessBoard = [], selectedCell = null, currentTurn = 'white', aiEnabled = false;
        let moveHistory = [], whiteKingPos = {r: 7, c: 4}, blackKingPos = {r: 0, c: 4};

        function initChess() {
            const setup = [
                'rnbqkbnr',
                'pppppppp',
                '........',
                '........',
                '........',
                '........',
                'PPPPPPPP',
                'RNBQKBNR'
            ];
            chessBoard = setup.map(row => row.split(''));
            selectedCell = null;
            currentTurn = 'white';
            moveHistory = [];
            whiteKingPos = {r: 7, c: 4};
            blackKingPos = {r: 0, c: 4};
            document.getElementById('chessTurn').textContent = 'White';
            document.getElementById('chessStatus').textContent = 'Select piece';
            document.getElementById('overChess').style.display = 'none';
            renderChess();
        }

        function renderChess() {
            const board = document.getElementById('chessBoard');
            board.innerHTML = '';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'chess-cell ' + ((r + c) % 2 === 0 ? 'light' : 'dark');
                    const piece = chessBoard[r][c];
                    if (piece !== '.') cell.textContent = chessPieces[piece];
                    
                    if (selectedCell && selectedCell.r === r && selectedCell.c === c) {
                        cell.classList.add('selected');
                    }
                    
                    if (selectedCell && isValidMove(selectedCell.r, selectedCell.c, r, c)) {
                        cell.classList.add('valid-move');
                    }
                    
                    cell.ontouchstart = (e) => {
                        e.preventDefault();
                        handleChessClick(r, c);
                    };
                    board.appendChild(cell);
                }
            }
        }

        function handleChessClick(r, c) {
            const piece = chessBoard[r][c];
            
            if (!selectedCell) {
                if (piece !== '.' && 
                    ((currentTurn === 'white' && piece === piece.toUpperCase()) ||
                     (currentTurn === 'black' && piece === piece.toLowerCase()))) {
                    selectedCell = {r, c};
                    document.getElementById('chessStatus').textContent = 'Select destination';
                    renderChess();
                }
            } else {
                if (isValidMove(selectedCell.r, selectedCell.c, r, c)) {
                    moveHistory.push({
                        board: chessBoard.map(row => [...row]),
                        turn: currentTurn,
                        whiteKing: {...whiteKingPos},
                        blackKing: {...blackKingPos}
                    });
                    
                    const movingPiece = chessBoard[selectedCell.r][selectedCell.c];
                    chessBoard[r][c] = movingPiece;
                    chessBoard[selectedCell.r][selectedCell.c] = '.';
                    
                    if (movingPiece.toLowerCase() === 'k') {
                        if (currentTurn === 'white') whiteKingPos = {r, c};
                        else blackKingPos = {r, c};
                    }
                    
                    if (movingPiece.toLowerCase() === 'p' && (r === 0 || r === 7)) {
                        chessBoard[r][c] = currentTurn === 'white' ? 'Q' : 'q';
                    }
                    
                    currentTurn = currentTurn === 'white' ? 'black' : 'white';
                    document.getElementById('chessTurn').textContent = currentTurn === 'white' ? 'White' : 'Black';
                    document.getElementById('chessStatus').textContent = 'Select piece';
                    
                    if (isCheckmate(currentTurn)) {
                        document.getElementById('chessResult').textContent = 'Checkmate!';
                        document.getElementById('chessWinner').textContent = (currentTurn === 'white' ? 'Black' : 'White') + ' Wins!';
                        document.getElementById('overChess').style.display = 'block';
                    }
                    
                    selectedCell = null;
                    renderChess();
                    
                    if (aiEnabled && currentTurn === 'black') {
                        setTimeout(makeAIMove, 500);
                    }
                } else {
                    selectedCell = null;
                    document.getElementById('chessStatus').textContent = 'Select piece';
                    renderChess();
                }
            }
        }

        function isValidMove(fromR, fromC, toR, toC) {
            const piece = chessBoard[fromR][fromC];
            const target = chessBoard[toR][toC];
            const dr = toR - fromR;
            const dc = toC - fromC;
            const type = piece.toLowerCase();
            
            if (target !== '.' && 
                ((piece === piece.toUpperCase() && target === target.toUpperCase()) ||
                 (piece === piece.toLowerCase() && target === target.toLowerCase()))) {
                return false;
            }
            
            let valid = false;
            switch(type) {
                case 'p':
                    const dir = piece === 'P' ? -1 : 1;
                    const startRow = piece === 'P' ? 6 : 1;
                    if (dc === 0 && dr === dir && target === '.') valid = true;
                    else if (dc === 0 && dr === 2 * dir && fromR === startRow && 
                             chessBoard[fromR + dir][fromC] === '.' && target === '.') valid = true;
                    else if (Math.abs(dc) === 1 && dr === dir && target !== '.') valid = true;
                    break;
                case 'r': valid = (dr === 0 || dc === 0) && clearPath(fromR, fromC, toR, toC); break;
                case 'b': valid = Math.abs(dr) === Math.abs(dc) && clearPath(fromR, fromC, toR, toC); break;
                case 'q': valid = (dr === 0 || dc === 0 || Math.abs(dr) === Math.abs(dc)) && clearPath(fromR, fromC, toR, toC); break;
                case 'n': valid = (Math.abs(dr) === 2 && Math.abs(dc) === 1) || (Math.abs(dr) === 1 && Math.abs(dc) === 2); break;
                case 'k': valid = Math.abs(dr) <= 1 && Math.abs(dc) <= 1; break;
            }
            
            if (!valid) return false;
            
            const tempBoard = chessBoard.map(r => [...r]);
            tempBoard[toR][toC] = tempBoard[fromR][fromC];
            tempBoard[fromR][fromC] = '.';
            
            const kingPos = type === 'k' ? {r: toR, c: toC} : 
                           (piece === piece.toUpperCase() ? whiteKingPos : blackKingPos);
            return !isSquareAttacked(kingPos.r, kingPos.c, piece === piece.toUpperCase() ? 'black' : 'white', tempBoard);
        }

        function clearPath(fromR, fromC, toR, toC) {
            const dr = Math.sign(toR - fromR);
            const dc = Math.sign(toC - fromC);
            let r = fromR + dr, c = fromC + dc;
            while (r !== toR || c !== toC) {
                if (chessBoard[r][c] !== '.') return false;
                r += dr;
                c += dc;
            }
            return true;
        }

        function isSquareAttacked(r, c, byColor, board = chessBoard) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece !== '.' && 
                        ((byColor === 'black' && piece === piece.toLowerCase()) ||
                         (byColor === 'white' && piece === piece.toUpperCase()))) {
                        if (canAttack(row, col, r, c, board)) return true;
                    }
                }
            }
            return false;
        }

        function canAttack(fromR, fromC, toR, toC, board) {
            const piece = board[fromR][fromC];
            const dr = toR - fromR;
            const dc = toC - fromC;
            const type = piece.toLowerCase();
            
            switch(type) {
                case 'p':
                    const dir = piece === 'P' ? -1 : 1;
                    return dr === dir && Math.abs(dc) === 1;
                case 'r': return (dr === 0 || dc === 0) && clearPathAttack(fromR, fromC, toR, toC, board);
                case 'b': return Math.abs(dr) === Math.abs(dc) && clearPathAttack(fromR, fromC, toR, toC, board);
                case 'q': return (dr === 0 || dc === 0 || Math.abs(dr) === Math.abs(dc)) && clearPathAttack(fromR, fromC, toR, toC, board);
                case 'n': return (Math.abs(dr) === 2 && Math.abs(dc) === 1) || (Math.abs(dr) === 1 && Math.abs(dc) === 2);
                case 'k': return Math.abs(dr) <= 1 && Math.abs(dc) <= 1;
            }
            return false;
        }

        function clearPathAttack(fromR, fromC, toR, toC, board) {
            const dr = Math.sign(toR - fromR);
            const dc = Math.sign(toC - fromC);
            let r = fromR + dr, c = fromC + dc;
            while (r !== toR || c !== toC) {
                if (board[r][c] !== '.') return false;
                r += dr;
                c += dc;
            }
            return true;
        }

        function isCheckmate(color) {
            if (!isInCheck(color)) return false;
            for (let fromR = 0; fromR < 8; fromR++) {
                for (let fromC = 0; fromC < 8; fromC++) {
                    const piece = chessBoard[fromR][fromC];
                    if (piece !== '.' && 
                        ((color === 'white' && piece === piece.toUpperCase()) ||
                         (color === 'black' && piece === piece.toLowerCase()))) {
                        for (let toR = 0; toR < 8; toR++) {
                            for (let toC = 0; toC < 8; toC++) {
                                if (isValidMove(fromR, fromC, toR, toC)) return false;
                            }
                        }
                    }
                }
            }
            return true;
        }

        function isInCheck(color) {
            const kingPos = color === 'white' ? whiteKingPos : blackKingPos;
            return isSquareAttacked(kingPos.r, kingPos.c, color === 'white' ? 'black' : 'white');
        }

        function undoChess() {
            if (moveHistory.length) {
                const prev = moveHistory.pop();
                chessBoard = prev.board;
                currentTurn = prev.turn;
                whiteKingPos = prev.whiteKing;
                blackKingPos = prev.blackKing;
                selectedCell = null;
                document.getElementById('chessTurn').textContent = currentTurn === 'white' ? 'White' : 'Black';
                renderChess();
            }
        }

        function toggleAIChess() {
            aiEnabled = !aiEnabled;
            document.getElementById('btnAIChess').textContent = aiEnabled ? 'ü§ñ AI: ON' : 'ü§ñ AI: OFF';
            if (aiEnabled && currentTurn === 'black') makeAIMove();
        }

        function makeAIMove() {
            let moves = [];
            for (let fromR = 0; fromR < 8; fromR++) {
                for (let fromC = 0; fromC < 8; fromC++) {
                    const piece = chessBoard[fromR][fromC];
                    if (piece !== '.' && piece === piece.toLowerCase()) {
                        for (let toR = 0; toR < 8; toR++) {
                            for (let toC = 0; toC < 8; toC++) {
                                if (isValidMove(fromR, fromC, toR, toC)) {
                                    moves.push({fromR, fromC, toR, toC, piece});
                                }
                            }
                        }
                    }
                }
            }
            
            if (moves.length) {
                moves.sort((a, b) => {
                    const valA = chessBoard[a.toR][a.toC] !== '.' ? 1 : 0;
                    const valB = chessBoard[b.toR][b.toC] !== '.' ? 1 : 0;
                    return valB - valA;
                });
                
                const move = moves[0];
                chessBoard[move.toR][move.toC] = move.piece;
                chessBoard[move.fromR][move.fromC] = '.';
                
                if (move.piece === 'k') blackKingPos = {r: move.toR, c: move.toC};
                
                currentTurn = 'white';
                document.getElementById('chessTurn').textContent = 'White';
                renderChess();
                
                if (isCheckmate('white')) {
                    document.getElementById('chessResult').textContent = 'Checkmate!';
                    document.getElementById('chessWinner').textContent = 'AI Wins!';
                    document.getElementById('overChess').style.display = 'block';
                }
            }
        }

        // ==================== GAME 8: SUDOKU (Virtual Numpad) ====================
        let sudokuGrid = [], sudokuSolution = [], selectedSudoku = null;
        let sudokuDifficulty = 30, solvedSudoku = 0;

        function setSudokuDifficulty(empty) {
            sudokuDifficulty = empty;
            document.querySelectorAll('#gameSudoku .diff-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            initSudoku();
        }

        function initSudoku() {
            sudokuSolution = generateSudoku();
            sudokuGrid = sudokuSolution.map(row => [...row]);
            
            let removed = 0;
            while (removed < sudokuDifficulty) {
                const r = Math.floor(Math.random() * 9);
                const c = Math.floor(Math.random() * 9);
                if (sudokuGrid[r][c] !== 0) {
                    sudokuGrid[r][c] = 0;
                    removed++;
                }
            }
            
            document.getElementById('overSudoku').style.display = 'none';
            document.getElementById('sudokuStatus').textContent = 'Select cell';
            selectedSudoku = null;
            renderSudoku();
            createSudokuKeyboard();
        }

        function generateSudoku() {
            const grid = Array(9).fill().map(() => Array(9).fill(0));
            solveSudokuGrid(grid);
            return grid;
        }

        function solveSudokuGrid(grid) {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (grid[r][c] === 0) {
                        const nums = [1,2,3,4,5,6,7,8,9].sort(() => Math.random() - 0.5);
                        for (let num of nums) {
                            if (isValidSudoku(grid, r, c, num)) {
                                grid[r][c] = num;
                                if (solveSudokuGrid(grid)) return true;
                                grid[r][c] = 0;
                            }
                        }
                        return false;
                    }
                }
            }
            return true;
        }

        function isValidSudoku(grid, r, c, num) {
            for (let i = 0; i < 9; i++) {
                if (grid[r][i] === num || grid[i][c] === num) return false;
            }
            const boxR = Math.floor(r / 3) * 3, boxC = Math.floor(c / 3) * 3;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (grid[boxR + i][boxC + j] === num) return false;
                }
            }
            return true;
        }

        function renderSudoku() {
            const grid = document.getElementById('sudokuGrid');
            grid.innerHTML = '';
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'sudoku-cell';
                    if (sudokuGrid[r][c] !== 0) {
                        cell.textContent = sudokuGrid[r][c];
                        if (sudokuSolution[r][c] === sudokuGrid[r][c]) cell.classList.add('fixed');
                    }
                    if (selectedSudoku && selectedSudoku.r === r && selectedSudoku.c === c) {
                        cell.classList.add('selected');
                    }
                    cell.ontouchstart = () => {
                        selectedSudoku = {r, c};
                        renderSudoku();
                    };
                    grid.appendChild(cell);
                }
            }
        }

        function createSudokuKeyboard() {
            const kb = document.getElementById('sudokuKeyboard');
            kb.innerHTML = '';
            const row = document.createElement('div');
            row.className = 'keyboard-row';
            for (let i = 1; i <= 9; i++) {
                const key = document.createElement('button');
                key.className = 'vkey';
                key.textContent = i;
                key.ontouchstart = () => inputSudokuNumber(i);
                row.appendChild(key);
            }
            const clear = document.createElement('button');
            clear.className = 'vkey wide';
            clear.textContent = 'Clear';
            clear.ontouchstart = () => inputSudokuNumber(0);
            row.appendChild(clear);
            kb.appendChild(row);
        }

        function inputSudokuNumber(num) {
            if (!selectedSudoku) return;
            const {r, c} = selectedSudoku;
            if (sudokuSolution[r][c] !== sudokuGrid[r][c] || num === 0) {
                sudokuGrid[r][c] = num;
                renderSudoku();
                checkWinSudoku();
            }
        }

        function checkWinSudoku() {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (sudokuGrid[r][c] !== sudokuSolution[r][c]) return;
                }
            }
            solvedSudoku++;
            document.getElementById('solvedSudoku').textContent = solvedSudoku;
            document.getElementById('overSudoku').style.display = 'block';
        }

        function solveSudoku() {
            sudokuGrid = sudokuSolution.map(row => [...row]);
            renderSudoku();
            checkWinSudoku();
        }

        function hintSudoku() {
            if (!selectedSudoku) return;
            const {r, c} = selectedSudoku;
            if (sudokuGrid[r][c] === 0) {
                sudokuGrid[r][c] = sudokuSolution[r][c];
                renderSudoku();
                checkWinSudoku();
            }
        }

        // ==================== GAME 9: PLATFORMER (Touch D-Pad) ====================
        let platX = 50, platY = 100, platVelX = 0, platVelY = 0;
        let platRunning = false, platScore = 0, platInterval, levelPlatformer = 1;
        let coins = [], platforms = [];
        let platMoveDir = 0;

        function initPlatformer() {
            platX = 50;
            platY = 100;
            platVelX = 0;
            platVelY = 0;
            platScore = 0;
            platMoveDir = 0;
            coins = [];
            platforms = [{x: 0, y: 160, w: 350, h: 40}];
            
            generateLevel();
            
            document.getElementById('scorePlatformer').textContent = '0';
            document.getElementById('levelPlatformer').textContent = levelPlatformer;
            document.getElementById('overPlatformer').style.display = 'none';
            renderPlatformer();
        }

        function generateLevel() {
            const canvas = document.getElementById('platformerCanvas');
            document.querySelectorAll('.platformer-coin').forEach(c => c.remove());
            
            for (let i = 0; i < 3 + levelPlatformer; i++) {
                platforms.push({
                    x: 100 + i * 80,
                    y: 120 - (i % 3) * 40,
                    w: 60,
                    h: 20
                });
            }
            
            for (let i = 0; i < 3 + Math.floor(levelPlatformer / 2); i++) {
                const coin = document.createElement('div');
                coin.className = 'platformer-coin';
                coin.style.left = (80 + i * 90) + 'px';
                coin.style.bottom = (140 + (i % 2) * 60) + 'px';
                canvas.appendChild(coin);
                coins.push({el: coin, collected: false, x: 80 + i * 90, y: 140 + (i % 2) * 60});
            }
        }

        function renderPlatformer() {
            const player = document.getElementById('platformerPlayer');
            player.style.left = platX + 'px';
            player.style.bottom = platY + 'px';
        }

        function updatePlatformer() {
            platVelY += 0.6;
            platVelX = platMoveDir * 5;
            platX += platVelX;
            platY += platVelY;

            let onGround = false;
            platforms.forEach(plat => {
                if (platX + 35 > plat.x && platX < plat.x + plat.w &&
                    platY <= plat.y + plat.h && platY >= plat.y && platVelY >= 0) {
                    platY = plat.y + plat.h;
                    platVelY = 0;
                    onGround = true;
                }
            });

            if (platY < -50) {
                platX = 50;
                platY = 100;
                platVelY = 0;
            }
            if (platX < 0) platX = 0;
            if (platX > 315) platX = 315;

            coins.forEach(coin => {
                if (!coin.collected && 
                    platX < coin.x + 25 && platX + 35 > coin.x &&
                    platY < coin.y + 25 && platY + 35 > coin.y) {
                    coin.collected = true;
                    coin.el.style.display = 'none';
                    platScore += 10;
                    document.getElementById('scorePlatformer').textContent = platScore;
                }
            });

            if (platX > 300 && coins.every(c => c.collected)) {
                levelComplete();
            }

            renderPlatformer();
        }

        function platMove(dir) {
            platMoveDir = dir;
        }

        function platStop() {
            platMoveDir = 0;
        }

        function platJump() {
            if (platVelY === 0) {
                platVelY = -12;
            }
        }

        function levelComplete() {
            clearInterval(platInterval);
            platRunning = false;
            document.getElementById('btnPlatformer').textContent = '‚ñ∂Ô∏è Start';
            document.getElementById('finalPlatformer').textContent = platScore;
            document.getElementById('overPlatformer').style.display = 'block';
        }

        function nextLevelPlatformer() {
            levelPlatformer++;
            initPlatformer();
            togglePlatformer();
        }

        function togglePlatformer() {
            if (platRunning) {
                clearInterval(platInterval);
                platRunning = false;
                document.getElementById('btnPlatformer').textContent = '‚ñ∂Ô∏è Resume';
            } else {
                platInterval = setInterval(updatePlatformer, 1000/60);
                platRunning = true;
                document.getElementById('btnPlatformer').textContent = '‚è∏Ô∏è Pause';
            }
        }

        // ==================== GAME 10: TOWER DEFENSE (Touch) ====================
        let tdGold = 100, tdLives = 20, tdWave = 0, tdRunning = false;
        let tdTowers = [], tdEnemies = [], tdProjectiles = [];
        let tdInterval, tdSpawnInterval;

        function initTD() {
            tdGold = 100;
            tdLives = 20;
            tdWave = 0;
            tdTowers = [];
            tdEnemies = [];
            tdProjectiles = [];
            tdRunning = false;
            clearInterval(tdInterval);
            clearInterval(tdSpawnInterval);
            document.getElementById('goldTD').textContent = tdGold;
            document.getElementById('livesTD').textContent = tdLives;
            document.getElementById('waveTD').textContent = tdWave;
            document.getElementById('overTD').style.display = 'none';
            document.getElementById('tdCanvas').innerHTML = '<div class="td-path"></div>';
            document.getElementById('btnTD').textContent = '‚ñ∂Ô∏è Wave';
        }

        function placeTower(e) {
            e.preventDefault();
            if (tdGold < 50) return;
            
            const rect = e.currentTarget.getBoundingClientRect();
            const x = e.touches[0].clientX - rect.left - 17;
            const y = e.touches[0].clientY - rect.top - 17;
            
            if (x > 110 && x < 190) return;

            const tower = document.createElement('div');
            tower.className = 'td-tower';
            tower.style.left = x + 'px';
            tower.style.top = y + 'px';
            tower.innerHTML = '‚ôú';
            tower.dataset.level = '1';
            document.getElementById('tdCanvas').appendChild(tower);
            
            tdTowers.push({
                x: x + 17, 
                y: y + 17, 
                element: tower,
                range: 80,
                damage: 1,
                cooldown: 0
            });
            
            tdGold -= 50;
            document.getElementById('goldTD').textContent = tdGold;
            createTouchFeedback(e.touches[0].clientX, e.touches[0].clientY);
        }

        function upgradeTowers() {
            if (tdGold >= 100) {
                tdGold -= 100;
                document.getElementById('goldTD').textContent = tdGold;
                tdTowers.forEach(tower => {
                    tower.range += 20;
                    tower.damage += 1;
                    tower.element.style.transform = 'scale(1.2)';
                });
            }
        }

        function toggleTD() {
            if (tdRunning) return;
            tdRunning = true;
            tdWave++;
            document.getElementById('waveTD').textContent = tdWave;
            document.getElementById('btnTD').textContent = 'Wave ' + tdWave;
            
            let spawned = 0;
            const toSpawn = 5 + tdWave * 2;
            
            tdSpawnInterval = setInterval(() => {
                if (spawned >= toSpawn) {
                    clearInterval(tdSpawnInterval);
                    return;
                }
                spawnEnemy();
                spawned++;
            }, 800);

            tdInterval = setInterval(updateTD, 50);
        }

        function spawnEnemy() {
            const enemy = document.createElement('div');
            enemy.className = 'td-enemy';
            enemy.style.left = '145px';
            enemy.style.top = '-30px';
            document.getElementById('tdCanvas').appendChild(enemy);
            
            tdEnemies.push({
                y: -30,
                x: 145,
                health: 3 + tdWave * 2,
                maxHealth: 3 + tdWave * 2,
                speed: 1 + tdWave * 0.3,
                element: enemy,
                value: 10 + tdWave * 5
            });
        }

        function updateTD() {
            tdEnemies.forEach((enemy, i) => {
                enemy.y += enemy.speed;
                enemy.element.style.top = enemy.y + 'px';
                
                tdTowers.forEach(tower => {
                    if (tower.cooldown > 0) tower.cooldown--;
                    
                    const dist = Math.hypot(tower.x - enemy.x, tower.y - enemy.y);
                    if (dist < tower.range && tower.cooldown <= 0) {
                        const proj = document.createElement('div');
                        proj.className = 'td-projectile';
                        proj.style.left = tower.x + 'px';
                        proj.style.top = tower.y + 'px';
                        document.getElementById('tdCanvas').appendChild(proj);
                        
                        tdProjectiles.push({
                            x: tower.x,
                            y: tower.y,
                            target: enemy,
                            element: proj,
                            damage: tower.damage
                        });
                        
                        tower.cooldown = 30;
                    }
                });

                if (enemy.y > 240) {
                    enemy.element.remove();
                    tdEnemies.splice(i, 1);
                    tdLives--;
                    document.getElementById('livesTD').textContent = tdLives;
                    
                    if (tdLives <= 0) gameOverTD();
                }
            });

            tdProjectiles.forEach((proj, i) => {
                if (!proj.target || !tdEnemies.includes(proj.target)) {
                    proj.element.remove();
                    tdProjectiles.splice(i, 1);
                    return;
                }
                
                const dx = proj.target.x - proj.x;
                const dy = proj.target.y - proj.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist < 10) {
                    proj.target.health -= proj.damage;
                    proj.element.remove();
                    tdProjectiles.splice(i, 1);
                    
                    if (proj.target.health <= 0) {
                        const idx = tdEnemies.indexOf(proj.target);
                        if (idx > -1) {
                            tdEnemies[idx].element.remove();
                            tdEnemies.splice(idx, 1);
                            tdGold += proj.target.value;
                            document.getElementById('goldTD').textContent = tdGold;
                        }
                    }
                } else {
                    proj.x += (dx / dist) * 8;
                    proj.y += (dy / dist) * 8;
                    proj.element.style.left = proj.x + 'px';
                    proj.element.style.top = proj.y + 'px';
                }
            });

            if (tdEnemies.length === 0 && !tdSpawnInterval) {
                tdRunning = false;
                document.getElementById('btnTD').textContent = '‚ñ∂Ô∏è Wave ' + (tdWave + 1);
                tdGold += 50;
                document.getElementById('goldTD').textContent = tdGold;
            }
        }

        function gameOverTD() {
            clearInterval(tdInterval);
            clearInterval(tdSpawnInterval);
            tdRunning = false;
            document.getElementById('finalWaveTD').textContent = tdWave;
            document.getElementById('overTD').style.display = 'block';
        }

        // ==================== INITIALIZATION ====================
        window.onload = () => {
            setTimeout(() => {
                document.querySelector('.loading')?.remove();
            }, 500);
            
            init2048();
            initSnake();
            initTetris();
            initWordle();
            initMines();
            initFlappy();
            initChess();
            initSudoku();
            initPlatformer();
            initTD();
        };
    </script>
</body>
</html>
